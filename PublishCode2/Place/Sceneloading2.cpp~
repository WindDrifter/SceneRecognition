#include "global.h"
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

void GenerateFeatureSet(cv::Mat img, const char* dir,const int maxsize,const int label,int& start,Array2d<double>& features,Array2dC<int>& labels,const bool generatePCA,std::ofstream* pcaout=NULL)
{


// for the UIUC scene classification set // Read images from one class (i.e. one directory)
    std::ostringstream buf;
    IntImage<double> im,temp;
    for(int i=0;i<maxsize;i++)
    {
 
        im.Load2(img);
        labels.buf[start]=label;
        for(int j=0;j<features.ncol;j++) features.p[start][j]=0;

        GenerateFeatureForSingleChannelImage(im,&features.p[start][0],(generatePCA && (i<100))?pcaout:NULL);
        // For UIUC scene classification data, use first 100 images of every class to generate PCA

        start++;
    }
}

void sceneDetection(){
// for no pic input // will auto capture camera
//CvImagePtr toCvCopy(const sensor_msgs::ImageConstPtr& source,
  //                   const std::string& encoding = std::string());

/*
I am not sure which type of camera we will be using, hence leaving this blank

*/
cv::Mat  image = imread("../Test/375.jpg", CV_LOAD_IMAGE_COLOR)

}

void sceneDetection(cv::Mat img){


    bool generatePCA = false; // whether we collect training data for PCA
    
    useSobel = false;
    useBoth = true;
    lf.Load(useSobel?"lf_UIUC_Sobel.txt":"lf_UIUC.txt",40,256); NormalizeLoadFactors(lf);
    if(useBoth)
    {
        lf2.Load("lf_UIUC_Sobel.txt",40,256);
        NormalizeLoadFactors(lf2);
    }
    sizeCV = 1;
    extra = 2;
    splitlevel = 2;
    splitratio[0] = 1.0; splitratio[1] = 1.0; splitratio[2] = 1.35;

    const int nClass = 1;
    const int imagesizes[nClass] = {1};
    const char* imagenames[nClass] = {""}; 
    const int classLabels[nClass] = { 0};
    const int totalNum = 1;

    Array2d<double> features;Array2dC<int> labels;
    features.Create(totalNum,splitlevel?(lf.nrow+extra)*splitsize[splitlevel]*(1+useBoth):(256+extra));
    labels.Create(1,features.nrow);
	std::ostringstream buf;
    std::ofstream pcaout;
    if(generatePCA) pcaout.open("pcatrain.txt"); // use first 100 images in each class to generate PCA
    int start=0;
    for(int i=0;i<nClass;i++)
	GenerateFeatureSet(img,imagenames[i],imagesizes[i],classLabels[i],start,features,labels,generatePCA,&pcaout);
    assert(start==features.nrow);
    if(generatePCA) 
    {
        pcaout.close();
        return;
    }
    const int size=features.nrow;
    Array2dC<bool> train(1,size);
    Array2dC<double> minmax(2,features.ncol);
    Array2dC<double> scaleratio(1,features.ncol); PrepareScaleRatio(scaleratio);

    unsigned seed = 1194575810; // unsigned seed=(unsigned)time(NULL);  // use 1194575810 to reproduce results in paper
    std::cout<<seed<<std::endl;
    my_srand(seed);
    for(int round=0;round<sizeCV;round++)
    {
        start=0;
        for(int i=0;i<nClass;i++)
        {
            int end = start;
            while(end<size && labels.buf[end]==labels.buf[start]) end++;

            Array2dC<int> perm(1,end-start);
            GenerateRandomPermutation(perm.buf,end-start);
            for(int j=0;j<100;j++) train.buf[start+perm.buf[j]] = true;
            start = end;
        }
        FindMinMaxValue(features,train,minmax);

        std::ostringstream buf;
        buf.str(""); buf<<"Data"; buf<<round+1; buf<<".txt";
        std::ofstream out(buf.str().c_str());
        for(int i=0;i<features.nrow;i++)
        {
	     
            if(i==0){  // since we only have one pic
                out<<labels.buf[i]<<" ";
	    }	
           	
            for(int j=0;j<features.ncol;j++) 
                out<<j+1<<":"<<((features.p[i][j]-minmax.p[0][j])*minmax.p[1][j]-1.0)*scaleratio.buf[j]<<" ";
            out<<std::endl;
        }
        out.close();       
    }
}
